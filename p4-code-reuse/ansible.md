# Extend P4-16

An overview of P4-16 extensions (`P4++`) is provided below.  `P4++` is used to write the customer P4 program.  The customer P4 program is merged with a regular P4 program and a final merged P4 program is generated by the P4-Ansible tool.  P4-Ansible uses a Python shell which provides commands to merge vendor and customer P4-16 programs.

## Extensions

### New keyword `override`
Examples for how the `override` keyword is used are provided below.

```p4
struct headers_t override { // tells compiler this is a "patch" to the previous type definition, not a new one.
    new_header_t new_header;
}

// tells compiler to patch previously
// defined parser with the same name ("base_parser")
parser base_parser(…) override {
    state ethernet override {  // override previously defined state definition
        ...
    }
    
    state new_state {  // if no override, then add the state as a new one
        ...
    }
}

control new_ingress(...) {  // no keyword used here, but the example shows how to merge two controls.
    old_ingress = base_ingress()
    apply {
        // new code is here
        // …
        old_ingress.apply();
    }
}

control new_deparser(...) override {
    // extended deparser here
}

package V1Switch(base_parser, new_ingers, new_deparser) override;  // tells compiler to ignore (drop) previous package declaration and use this one
	
```
## New Keywords: `super.xxx.transition`
`xxx` in syntax above is a parser state.

An example use of syntax in merging two P4 programs is shown below.

```p4
base.p4
---------
parser base_parser {
    state parse_ipv4_state {
        extract(hdr.ipv4);
        transition accept;
    }

    state parse_ethernet {
        extract(hdr.eth);
        transition (hdr.eth.ethertype) {
            IPV4: parse_ipv4_state;
            default: accept;
        }
    }
}
```

```p4
extended.p4
------------
parser base_parser override {
    state parse_ipv6_state {
        extract(hdr.ipv6);
        transition accept;
    }

    state parse_ethernet override {
        extract(hdr.eth);
        transition (hdr.eth.ethertype) {
            IPV6: parse_ipv6_state;
            // no need to extract, only switch based
            // on already extracted header
            default: super.parse_ethernet.transition;
        }
    }
}
```

We need to combine the two into one standard p4 program as follows.

```p4
parser base_parser { 
    state parse_ipv6_state {
        extract(hdr.ipv6);
        transition accept;
    }

    state _parse_ipv4_state {
        extract(hdr.ipv4);
        transition accept;
    }

    // original base state
    state parse_ethernet_transition {
        transition (hdr.eth.ethertype) {
            IPV4: parse_ipv4_state;
            default: accept;
        }
    }

    // extended state
    state parse_ethernet {
        extract(hdr.eth);
        transition (hdr.eth.ethertype) {
            IPV6: ipv6_state;
            // replace super reference with the name of the newly created transition part of the base state
            default: parse_ethernet_transition;
        }
    }
}
```

## Override for Tables and Actions

```p4
// Augmenting action parameter and action body is supported. Defaults to adding
// body to end.
action set_port_properties(...) override {  // tells compiler to patch previously
    // defined action.
}

// tells compiler to allow adding new action.
action New_action() {

}
table ipv4_acl override {
key override = {  // Patch new key element
// new key element.
}
actions override = {  // Patch to existing actions.
New_action;
}
default_action override = action_x;  // tells compiler to use this action as default_action.
}
```

## Misc
```p4
control foo(…) override {
    action moo(…) override {
        // new code here
        super.moo(); // call base action.
    }
    apply {
        // new code
        super.apply(); // call apply method from the base code.
        // more new code
    }
}
```

```p4
// Augmenting action parameter and action body is supported. 
// Defaults to adding new body to end.
action foo(...) override {  // tells compiler to patch previously defined action.
    ...
}

// tells compiler to allow adding new action.
action New_action() {
    ...
}

table moo override {
    key override = {  // Patch new key element
        // new key element.
    }
    
    actions override = {  // Patch to existing actions.
        New_action;
    }  
    
    default_action override = action_x;  // tells compiler to use this action as default_action.
}
```
